<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>IPTV è½‰æ›å·¥å…· - å–®é è‡ªå‹•ç‰ˆ</title>
    <style>
        :root { --primary: #1a73e8; --success: #34a853; --bg: #f8f9fa; }
        body { font-family: "Segoe UI", "Microsoft JhengHei", sans-serif; margin: 0; background: var(--bg); height: 100vh; overflow: hidden; }
        
        /* é ‚éƒ¨å°èˆª */
        header { background: white; padding: 10px 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; justify-content: space-between; align-items: center; height: 50px; box-sizing: border-box; }
        h1 { font-size: 1.2rem; margin: 0; color: var(--primary); }

        /* ä¸»å®¹å™¨ */
        main { display: flex; height: calc(100vh - 50px); padding: 15px; gap: 15px; box-sizing: border-box; }

        /* å·¦å´æ§åˆ¶æ¬„ */
        .left-panel { flex: 0 0 350px; display: flex; flex-direction: column; gap: 15px; }
        
        /* å³å´é è¦½æ¬„ */
        .right-panel { flex: 1; display: flex; flex-direction: column; gap: 15px; }

        .card { background: white; padding: 15px; border-radius: 8px; border: 1px solid #e0e0e0; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .status-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; background: #ccc; }
        .status-ok { background: var(--success); box-shadow: 0 0 5px var(--success); }
        
        /* æ“ä½œæ—¥èªŒ */
        #log { flex: 1; background: #2d3436; color: #dfe6e9; padding: 10px; border-radius: 6px; font-family: Consolas, monospace; font-size: 12px; overflow-y: auto; line-height: 1.4; }

        /* é è¦½è¦–çª— */
        .preview-container { flex: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; min-height: 0; }
        .preview-box { display: flex; flex-direction: column; }
        textarea { flex: 1; resize: none; font-family: Consolas, monospace; font-size: 12px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: #fff; }

        /* æŒ‰éˆ•æ¨£å¼ */
        button { padding: 10px; cursor: pointer; border-radius: 5px; border: none; font-weight: bold; transition: 0.2s; }
        .btn-main { background: var(--primary); color: white; width: 100%; font-size: 1rem; margin-top: 10px; }
        .btn-main:hover { background: #1557b0; }
        .btn-download { background: var(--success); color: white; margin-top: 8px; }
        
        input[type="file"] { width: 100%; font-size: 0.9rem; }
        small { color: #666; font-size: 0.8rem; }
    </style>
</head>
<body>

<header>
    <h1>IPTV è½‰æ›ç®¡ç†ç³»çµ±</h1>
    <div>
        <span id="dot" class="status-dot"></span>
        <small id="ruleStatus">æ­£åœ¨åµæ¸¬ all_rules.txt...</small>
    </div>
</header>

<main>
    <div class="left-panel">
        <div class="card">
            <strong>1. ä¾†æºä¸Šå‚³</strong>
            <input type="file" id="tvInput" onchange="loadTvFile(this)" style="margin: 10px 0;">
            <small id="tvStatus">ç­‰å¾…é¸æ“‡ tv.txt</small>
            <button class="btn-main" onclick="startConvert()">ç«‹å³è½‰æ›</button>
        </div>
        
        <div class="card" style="flex: 1; display: flex; flex-direction: column;">
            <strong>2. æ“ä½œæ—¥èªŒ (Log)</strong>
            <div id="log"></div>
        </div>
    </div>

    <div class="right-panel">
        <div class="preview-container">
            <div class="preview-box">
                <strong>TXT é è¦½</strong>
                <textarea id="txtPreview" readonly></textarea>
                <button class="btn-download" onclick="downloadFile('iptv', 'txt', txtOutput)">ğŸ“¥ ä¸‹è¼‰ .txt</button>
            </div>
            <div class="preview-box">
                <strong>M3U é è¦½</strong>
                <textarea id="m3uPreview" readonly></textarea>
                <button class="btn-download" onclick="downloadFile('iptv', 'm3u', m3uOutput)">ğŸ“¥ ä¸‹è¼‰ .m3u</button>
            </div>
        </div>
    </div>
</main>

<script>
    let tvContent = null;
    let keepSet = new Set(), categoryMap = [], sortRef = {};
    let txtOutput = "", m3uOutput = "";

    // å•Ÿå‹•è‡ªå‹•åŠ è¼‰
    window.onload = function() {
        addLog("é€£ç·šè‡³ GitHub è®€å– all_rules.txt...");
        fetch('all_rules.txt', { cache: "no-store" })
            .then(res => {
                if (!res.ok) throw new Error("è®€å–å¤±æ•—ï¼šè«‹ç¢ºèªæª”æ¡ˆå­˜åœ¨");
                return res.text();
            })
            .then(text => {
                parseAllRules(text);
                document.getElementById("dot").className = "status-dot status-ok";
                document.getElementById("ruleStatus").textContent = "è¦å‰‡å·²å°±ç·’";
                addLog("è¦å‰‡è¼‰å…¥æˆåŠŸï¼šä¿ç•™ " + keepSet.size + " é …", "success");
            })
            .catch(err => {
                addLog(err.message, "error");
                document.getElementById("ruleStatus").textContent = "è¦å‰‡è¼‰å…¥å¤±æ•—";
            });
    };

    function addLog(msg, type = "normal") {
        const div = document.createElement("div");
        if(type === "error") div.style.color = "#ff7675";
        if(type === "success") div.style.color = "#55efc4";
        div.textContent = `[${new Date().toLocaleTimeString().split(' ')[0]}] ${msg}`;
        const l = document.getElementById("log");
        l.appendChild(div);
        l.scrollTop = l.scrollHeight;
    }

    function parseAllRules(text) {
        const lines = text.split(/\r?\n/);
        let section = "";
        let curCat = null, curSortCat = null;
        lines.forEach(l => {
            let line = l.trim();
            if (!line || line.startsWith("#")) return;
            if (line === "[KEEP_LIST]") { section = "KEEP"; return; }
            if (line === "[CATEGORY_LIST]") { section = "CATEGORY"; return; }
            if (line === "[SORT_LIST]") { section = "SORT"; return; }

            if (section === "KEEP") keepSet.add(line.toUpperCase());
            else if (section === "CATEGORY") {
                if (line.includes("#genre#")) {
                    curCat = { name: line.split(",")[0].trim(), keywords: [] };
                    categoryMap.push(curCat);
                } else if (curCat) curCat.keywords.push(line.toUpperCase());
            } else if (section === "SORT") {
                if (line.includes("#genre#")) {
                    curSortCat = line.split(",")[0].trim();
                    sortRef[curSortCat] = [];
                } else if (curSortCat) sortRef[curSortCat].push(line.toUpperCase());
            }
        });
    }

    function loadTvFile(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            tvContent = e.target.result;
            document.getElementById("tvStatus").textContent = "âœ… å·²è¼‰å…¥ " + file.name;
            addLog("é »é“æºè¼‰å…¥æˆåŠŸ");
        };
        reader.readAsText(file, "utf-8");
    }

    function channelSorter(a, b, catName) {
        const refList = sortRef[catName] || [];
        let idxA = refList.findIndex(k => a.upper.includes(k));
        let idxB = refList.findIndex(k => b.upper.includes(k));
        if (idxA !== -1 && idxA === idxB) return a.name.localeCompare(b.name, 'zh-Hant', { numeric: true });
        if (idxA !== -1 && idxB !== -1) return idxA - idxB;
        if (idxA !== -1) return -1;
        if (idxB !== -1) return 1;
        return a.name.localeCompare(b.name, 'zh-Hant', { numeric: true });
    }

    function startConvert() {
        if (!tvContent || keepSet.size === 0) return addLog("éŒ¯èª¤ï¼šè³‡æ–™ä¸é½Šå…¨", "error");
        addLog("è™•ç†ä¸­...");
        const lines = tvContent.split(/\r?\n/);
        let results = {}, finalCount = 0;

        lines.forEach(line => {
            line = line.trim();
            if (!line || line.includes("#genre#")) return;
            const parts = line.split(",");
            if (parts.length < 2) return;
            const nameRaw = parts[0].trim(), url = parts[1].trim(), nameUpper = nameRaw.toUpperCase();

            let isKept = false;
            for (let k of keepSet) { if (nameUpper.includes(k)) { isKept = true; break; } }
            if (!isKept) return;

            let foundCat = "å…¶ä»–";
            for (let cat of categoryMap) {
                if (cat.keywords.some(kw => nameUpper.includes(kw))) { foundCat = cat.name; break; }
            }
            if (!results[foundCat]) results[foundCat] = [];
            results[foundCat].push({ name: nameRaw, url: url, upper: nameUpper });
            finalCount++;
        });

        txtOutput = ""; m3uOutput = "#EXTM3U\n";
        categoryMap.forEach(cat => {
            if (results[cat.name]) {
                results[cat.name].sort((a, b) => channelSorter(a, b, cat.name));
                txtOutput += `${cat.name},#genre#\n`;
                results[cat.name].forEach(i => {
                    txtOutput += `${i.name},${i.url}\n`;
                    m3uOutput += `#EXTINF:-1 group-title="${cat.name}",${i.name}\n${i.url}\n`;
                });
                delete results[cat.name];
            }
        });
        document.getElementById("txtPreview").value = txtOutput;
        document.getElementById("m3uPreview").value = m3uOutput;
        addLog(`æˆåŠŸï¼å…± ${finalCount} å€‹é »é“`, "success");
    }

    function downloadFile(prefix, ext, content) {
        if (!content) return;
        const now = new Date();
        const ts = now.getFullYear() + String(now.getMonth() + 1).padStart(2, '0') + String(now.getDate()).padStart(2, '0') + "_" + String(now.getHours()).padStart(2, '0') + String(now.getMinutes()).padStart(2, '0');
        const filename = `${prefix}_${ts}.${ext}`;
        const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
    }
</script>
</body>
</html>
