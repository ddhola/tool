<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>IPTV è½‰æ›ç®¡ç†ç³»çµ±</title>
    <style>
        :root { --primary: #1a73e8; --success: #34a853; --warning: #f9ab00; --error: #ea4335; --bg: #f8f9fa; }
        body { font-family: "Segoe UI", "Microsoft JhengHei", sans-serif; margin: 0; background: var(--bg); height: 100vh; overflow: hidden; }
        header { background: white; padding: 10px 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; justify-content: space-between; align-items: center; height: 50px; box-sizing: border-box; }
        h1 { font-size: 1.1rem; margin: 0; color: var(--primary); }
        main { display: flex; height: calc(100vh - 50px); padding: 12px; gap: 12px; box-sizing: border-box; }
        .left-panel { flex: 0 0 320px; display: flex; flex-direction: column; gap: 12px; }
        .right-panel { flex: 1; display: flex; flex-direction: column; gap: 12px; }
        .card { background: white; padding: 12px; border-radius: 8px; border: 1px solid #ddd; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .status-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; background: #ccc; }
        .dot-green { background: var(--success); box-shadow: 0 0 5px var(--success); }
        .dot-blue { background: var(--primary); box-shadow: 0 0 5px var(--primary); }
        .dot-red { background: var(--error); box-shadow: 0 0 5px var(--error); }
        #log { flex: 1; background: #2d3436; color: #dfe6e9; padding: 10px; border-radius: 6px; font-family: Consolas, monospace; font-size: 11px; overflow-y: auto; line-height: 1.4; }
        .preview-container { flex: 1; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; min-height: 0; }
        textarea { flex: 1; resize: none; font-family: Consolas, monospace; font-size: 11px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 8px 12px; cursor: pointer; border-radius: 5px; border: none; font-weight: bold; font-size: 13px; }
        .btn-main { background: var(--primary); color: white; width: 100%; margin-top: 10px; }
        .btn-update { background: #eee; color: #333; width: 100%; border: 1px solid #ccc; margin-top: 5px; }
        .btn-download { background: var(--success); color: white; margin-top: 5px; width: 100%; }
    </style>
</head>
<body>

<header>
    <h1>IPTV è½‰æ›ç®¡ç†ç³»çµ± (åŒæ­¥å„ªå…ˆç‰ˆ)</h1>
    <div>
        <span id="dot" class="status-dot"></span>
        <small id="ruleStatus">åˆå§‹åŒ–...</small>
    </div>
</header>

<main>
    <div class="left-panel">
        <div class="card">
            <strong>1. è¦å‰‡ç®¡ç†</strong>
            <input type="file" id="ruleFileManual" style="display:none;" onchange="loadRuleManual(this)">
            <button class="btn-update" onclick="document.getElementById('ruleFileManual').click()">ğŸ“‚ æ‰‹å‹•æ›´æ–°è¦å‰‡æª”</button>
            <small style="display:block; margin-top:5px; color:#888;">å„ªå…ˆè®€å–ä¼ºæœå™¨ all_rules.txt</small>
        </div>

        <div class="card">
            <strong>2. ä¾†æºä¸Šå‚³ (txt/m3u)</strong>
            <input type="file" accept=".txt,.m3u" onchange="loadTvFile(this)" style="margin: 10px 0; width:100%;">
            <button class="btn-main" onclick="startConvert()">ç«‹å³è½‰æ›</button>
        </div>
        <div id="log"></div>
    </div>

    <div class="right-panel">
        <div class="preview-container">
            <div style="display:flex; flex-direction:column;">
                <small>TXT é è¦½</small>
                <textarea id="txtPreview" readonly></textarea>
                <button class="btn-download" onclick="download('txt')">ğŸ“¥ ä¸‹è¼‰ TXT</button>
            </div>
            <div style="display:flex; flex-direction:column;">
                <small>M3U é è¦½</small>
                <textarea id="m3uPreview" readonly></textarea>
                <button class="btn-download" onclick="download('m3u')">ğŸ“¥ ä¸‹è¼‰ M3U</button>
            </div>
        </div>
    </div>
</main>

<script>
    let tvContent = null, keepSet = new Set(), categoryMap = [], sortRef = {};
    let txtOutput = "", m3uOutput = "";

    window.onload = function() {
        initRuleFlow();
    };

    // è¦å‰‡è¼‰å…¥æ ¸å¿ƒæµ
    async function initRuleFlow() {
        addLog("æ­£åœ¨é€£ç·šæŠ“å–ä¼ºæœå™¨ all_rules.txt...");
        
        try {
            const res = await fetch('all_rules.txt', { cache: "no-store" });
            if (!res.ok) throw new Error("File not found");
            const text = await res.text();
            
            parseRules(text);
            localStorage.setItem('all_rules_cache', text); // åŒæ­¥æ›´æ–°å¿«å–
            setUIState("dot-green", "è¦å‰‡å·²å°±ç·’ (æœ€æ–°)");
            addLog("ä¼ºæœå™¨è¦å‰‡æŠ“å–æˆåŠŸ (ç¶ ç‡ˆ)", "success");
        } catch (err) {
            addLog("ç„¡æ³•é€£ç·šä¼ºæœå™¨ï¼Œå˜—è©¦è®€å–æœ¬åœ°è¨˜æ†¶...", "error");
            const cached = localStorage.getItem('all_rules_cache');
            if (cached) {
                parseRules(cached);
                setUIState("dot-blue", "è¦å‰‡å·²å°±ç·’ (å¿«å–)");
                addLog("å·²è¼‰å…¥ä¸Šæ¬¡ä½¿ç”¨çš„è¨˜æ†¶è¦å‰‡ (è—ç‡ˆ)", "success");
            } else {
                setUIState("dot-red", "è¦å‰‡ç¼ºå¤±ï¼Œè«‹æ‰‹å‹•æ›´æ–°");
                addLog("æ‰¾ä¸åˆ°ä»»ä½•è¦å‰‡ï¼Œè«‹æ‰‹å‹•é¸æ“‡ all_rules.txt", "error");
            }
        }
    }

    function setUIState(dotClass, msg) {
        const dot = document.getElementById("dot");
        dot.className = "status-dot " + dotClass;
        document.getElementById("ruleStatus").textContent = msg;
    }

    function loadRuleManual(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            const text = e.target.result;
            localStorage.setItem('all_rules_cache', text);
            parseRules(text);
            setUIState("dot-green", "è¦å‰‡å·²æ‰‹å‹•æ›´æ–°");
            addLog(`æ‰‹å‹•æ›´æ–°è¦å‰‡æˆåŠŸ: ${file.name}`, "success");
            if (tvContent) startConvert(); // å¦‚æœå·²ç¶“æœ‰é »é“æºï¼Œè‡ªå‹•é‡è·‘
        };
        reader.readAsText(file, "utf-8");
    }

    function parseRules(text) {
        keepSet.clear(); categoryMap = []; sortRef = {};
        const lines = text.split(/\r?\n/);
        let section = "";
        let curCat = null, curSortCat = null;
        lines.forEach(l => {
            let line = l.trim();
            if (!line || line.startsWith("#")) return;
            if (line === "[KEEP_LIST]") { section = "KEEP"; return; }
            if (line === "[CATEGORY_LIST]") { section = "CATEGORY"; return; }
            if (line === "[SORT_LIST]") { section = "SORT"; return; }

            if (section === "KEEP") keepSet.add(line.toUpperCase());
            else if (section === "CATEGORY") {
                if (line.includes("#genre#")) {
                    curCat = { name: line.split(",")[0].trim(), keywords: [] };
                    categoryMap.push(curCat);
                } else if (curCat) curCat.keywords.push(line.toUpperCase());
            } else if (section === "SORT") {
                if (line.includes("#genre#")) {
                    curSortCat = line.split(",")[0].trim();
                    sortRef[curSortCat] = [];
                } else if (curSortCat) sortRef[curSortCat].push(line.toUpperCase());
            }
        });
    }

    function addLog(msg, type) {
        const div = document.createElement("div");
        if(type === "error") div.style.color = "#ff7675";
        if(type === "success") div.style.color = "#55efc4";
        div.textContent = `[${new Date().toLocaleTimeString().split(' ')[0]}] ${msg}`;
        const l = document.getElementById("log");
        l.appendChild(div);
        l.scrollTop = l.scrollHeight;
    }

    function loadTvFile(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            tvContent = e.target.result;
            addLog(`é »é“æºè¼‰å…¥æˆåŠŸ: ${file.name}`);
        };
        reader.readAsText(file, "utf-8");
    }

    function startConvert() {
        if (!tvContent || keepSet.size === 0) return addLog("éŒ¯èª¤ï¼šè¦å‰‡æˆ–é »é“æºæœªå°±ç·’", "error");
        
        let sourceData = [];
        if (tvContent.trim().startsWith("#EXTM3U")) {
            const lines = tvContent.split(/\r?\n/);
            for (let i=0; i<lines.length; i++) {
                if (lines[i].startsWith("#EXTINF")) {
                    const name = lines[i].split(",").pop().trim();
                    const url = lines[i+1]?.trim() || "";
                    if (url && !url.startsWith("#")) { sourceData.push({name, url}); i++; }
                }
            }
        } else {
            sourceData = tvContent.split(/\r?\n/).map(l => {
                const p = l.split(",");
                return p.length >= 2 ? {name: p[0].trim(), url: p[1].trim()} : null;
            }).filter(x => x && !x.url.includes("#genre#"));
        }

        let results = {}, seenUrls = new Set(), finalCount = 0;
        sourceData.forEach(item => {
            if (seenUrls.has(item.url)) return;
            const up = item.name.toUpperCase();
            let keep = false;
            for (let k of keepSet) { if (up.includes(k)) { keep = true; break; } }
            if (!keep) return;

            seenUrls.add(item.url);
            let cat = "å…¶ä»–";
            for (let c of categoryMap) { if (c.keywords.some(k => up.includes(k))) { cat = c.name; break; } }
            if (!results[cat]) results[cat] = [];
            results[cat].push({name: item.name, url: item.url, up});
            finalCount++;
        });

        txtOutput = ""; m3uOutput = "#EXTM3U\n";
        categoryMap.forEach(c => {
            if (results[c.name]) {
                const ref = sortRef[c.name] || [];
                results[c.name].sort((a,b) => {
                    let iA = ref.findIndex(k => a.up.includes(k)), iB = ref.findIndex(k => b.up.includes(k));
                    if (iA !== -1 && iA === iB) return a.name.localeCompare(b.name, 'zh-Hant', {numeric:true});
                    if (iA !== -1 && iB !== -1) return iA - iB;
                    return (iA !== -1) ? -1 : (iB !== -1) ? 1 : a.name.localeCompare(b.name, 'zh-Hant', {numeric:true});
                });
                txtOutput += `${c.name},#genre#\n`;
                results[c.name].forEach(i => {
                    txtOutput += `${i.name},${i.url}\n`;
                    m3uOutput += `#EXTINF:-1 group-title="${c.name}",${i.name}\n${i.url}\n`;
                });
            }
        });
        document.getElementById("txtPreview").value = txtOutput;
        document.getElementById("m3uPreview").value = m3uOutput;
        addLog(`è½‰æ›å®Œæˆï¼å…± ${finalCount} å€‹é »é“`, "success");
    }

    function download(ext) {
        const content = ext === 'txt' ? txtOutput : m3uOutput;
        if (!content) return;
        const ts = new Date().toISOString().replace(/[-:T]/g, '').slice(0, 14);
        const blob = new Blob([content], {type: "text/plain;charset=utf-8"});
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `iptv_${ts}.${ext}`;
        a.click();
    }
</script>
</body>
</html>
